# -*- coding: utf-8 -*-
"""notebook49fd350f6b

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/salonigargb21ai036/notebook49fd350f6b.fd26f24c-bfad-49f7-b2b8-d67d458d54f1.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250413/auto/storage/goog4_request%26X-Goog-Date%3D20250413T021732Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D0ef2dd322d09204b70930a093029f8cf9f04c376b269f213b37d5d351afb0347a4e152840312329e07c68edc9e63aff5c895aac6d9849bc1c02145a3f75d2ec6e7515dfff61e0bd54b8b32fd69ad8d7fa8a8cef9bb00fe0d90568b5eaa5fb38963ef911f6a07b5df1ff808a7e94a5afebdac2de25e14a14a60808d7100a6ea88682ce2aaf1bdadf82d8495d890aeb27a265e62794858bfe6be8cb5e3af073f625625f2c3657f03af6e9436ff816fad1cd1f1b22934564eba8835eb16d38671dfb5a00b1fd51e80cde4dcd15ad0ce05067b95fcd301d7dc5bc4c46d6fe106cb1cfa8cb1e62c4620979547f2d09532de3796bd58b7c0610cfcee4eb1fb38dd4815
"""

# IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.
import kagglehub
fareselmenshawii_face_detection_dataset_path = kagglehub.dataset_download('fareselmenshawii/face-detection-dataset')

print('Data source import complete.')

!pip install torch torchvision facenet-pytorch opencv-python numpy scikit-learn matplotlib tqdm

import os
from PIL import Image, ImageDraw
from facenet_pytorch import MTCNN
import matplotlib.pyplot as plt

import os
import random
from PIL import Image
import matplotlib.pyplot as plt

# Directory containing all validation images
image_dir = "/kaggle/input/face-detection-dataset/images/train"

# Get list of all .jpeg image paths
all_image_paths = [os.path.join(image_dir, fname) for fname in os.listdir(image_dir) if fname.endswith(".jpg")]

# Randomly select 10 images
image_paths = random.sample(all_image_paths, 10)

# Define the output folder path
output_folder = "/kaggle/working/output_images"

# Create the output folder if it doesn't exist
os.makedirs(output_folder, exist_ok=True)

# Loop through the image paths and plot each image one by one
for idx, image_path in enumerate(image_paths):
    if os.path.exists(image_path):
        image = Image.open(image_path)

        # Create a new figure for each image
        plt.figure(figsize=(5, 5))
        plt.imshow(image)
        plt.title(f"Image {idx + 1}")
        plt.axis("off")
        plt.show()

        # Save the image to the output folder
        output_image_path = os.path.join(output_folder, f"image_{idx + 1}.png")
        image.save(output_image_path)

    else:
        print(f"Image not found: {image_path}")

# Function to calculate IoU
def calculate_iou(box1, box2):
    # Calculate intersection
    x1 = max(box1[0], box2[0])
    y1 = max(box1[1], box2[1])
    x2 = min(box1[2], box2[2])
    y2 = min(box1[3], box2[3])
    intersection = max(0, x2 - x1) * max(0, y2 - y1)

    # Calculate union
    area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])
    area2 = (box2[2] - box2[0]) * max(0, box2[3] - box2[1])
    union = area1 + area2 - intersection

    return intersection / union if union > 0 else 0

# Set the paths to the validation images and labels
val_images_path = '/kaggle/input/face-detection-dataset/images/val'
val_labels_path = '/kaggle/input/face-detection-dataset/labels/val'

# Initialize MTCNN for face detection
mtcnn = MTCNN(keep_all=True)

# Function to convert relative to absolute bounding boxes
def relative_to_absolute(bbox, img_width, img_height):
    if len(bbox) < 4:
        return None  # Handle cases where there are not enough values
    center_x, center_y, width, height = bbox[:4]  # Extract four values
    abs_x1 = (center_x - width / 2) * img_width
    abs_y1 = (center_y - height / 2) * img_height
    abs_x2 = (center_x + width / 2) * img_width
    abs_y2 = (center_y + height / 2) * img_height
    return (abs_x1, abs_y1, abs_x2, abs_y2)

# Function to detect and draw faces
def detect_and_draw_faces(img_path, ground_truth_boxes):
    try:
        img = Image.open(img_path).convert('RGB')
        img_width, img_height = img.size

        # Convert ground truth boxes from relative to absolute coordinates
        absolute_boxes = [
            relative_to_absolute(box, img_width, img_height) for box in ground_truth_boxes
        ]

        # Filter out any None values
        absolute_boxes = [box for box in absolute_boxes if box]

        boxes, _ = mtcnn.detect(img)

        if boxes is not None:
            img_draw = img.copy()
            draw = ImageDraw.Draw(img_draw)
            for box in boxes:
                draw.rectangle(box.tolist(), outline="red", width=3)

            # Calculate IoU for each detected box
            ious = []
            for box in boxes:
                best_iou = 0
                for gt_box in absolute_boxes:
                    iou = calculate_iou(box, gt_box)
                    best_iou = max(best_iou, iou)
                ious.append(best_iou)

            # Log the detected and ground truth bounding boxes
            print(f"Detected boxes for {os.path.basename(img_path)}: {boxes}")
            print(f"Ground truth boxes for {os.path.basename(img_path)}: {absolute_boxes}")

            return img_draw, ious
        else:
            print(f"No faces detected in {os.path.basename(img_path)}")
            return None, []

    except Exception as e:
        print(f"Error processing {os.path.basename(img_path)}: {e}")
        return None, []

# Get the first five images from the validation folder
image_files = [f for f in os.listdir(val_images_path) if f.lower().endswith(('.jpg', '.jpeg', '.png'))]
num_images_to_process = min(5, len(image_files))  # Limit to five images

plt.figure(figsize=(12, 8))
total_ious = []

for idx, img_name in enumerate(image_files[:num_images_to_process]):
    img_path = os.path.join(val_images_path, img_name)

    # Create label file path
    label_path = os.path.join(val_labels_path, img_name.split('.')[0] + '.txt')

    if not os.path.exists(label_path):
        print(f"Label file not found for {img_name}")
        continue  # Skip this image if no label found

    # Read ground truth bounding boxes
    with open(label_path, 'r') as f:
        try:
            ground_truth_boxes = [tuple(map(float, line.strip().split())) for line in f]
        except ValueError:
            print(f"Error reading label data for {img_name}")
            continue  # Skip this image if label data is incorrect

    img_with_boxes, ious = detect_and_draw_faces(img_path, ground_truth_boxes)
    total_ious.extend(ious)

    if img_with_boxes:
        plt.subplot(1, 5, idx + 1)
        plt.title(f"Testing Image {idx + 1}")
        plt.imshow(img_with_boxes)
        plt.axis("off")

plt.tight_layout()
plt.show()

# Calculate the mean IoU
mean_iou = sum(total_ious) / len(total_ious) if total_ious else 0
print(f"Mean IoU: {mean_iou}")